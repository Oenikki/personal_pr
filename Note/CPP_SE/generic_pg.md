# 泛型编程

按照习惯，函数和类的声明应放在文件中，实现放在一个主代码文件. 但是模板是随用随生成，并不存在真正函数实现代码。

**明确生成模板实例：**当关键词后没有模板参数列表，而是一个函数声明时，指示编译器根据此函数声明寻找合适的模板实现。

## 基础知识

+ 关注函数模板参数自动推导
+ 关注类模板参数自动推导（C++17）

函数模板推导的需要注意的点：

+ **只能**根据函数的调用的实参列表来推导模板参数值
+ 与函数返回值无关的模板参数其值也无法推导
+ 所有可推导模板参数必须是连续位于模板参数列表尾部



...

## 一、函数模板

函数模板有两阶段编译检查

1. 模板定义阶段，检查部分内容例如语法、类型名，函数名
2. 模板实例化阶段，检查依赖于类型参数的部分

### 1. 模板参数推断

类型推断中的类型转换：

+ 参数为**引用**，无法进行转换
+ 参数按**值**传递，decay简单转换可以接受
  + 诸如const int -> int
  + int& -> int
  + arr[4] -> int* (int arr[4])
  + ...

**返回类型推断**

C++14可以由编译器推断返回类型，无需尾置返回类型decltype 

```c++
template<typename T1, template T2>
auto max(T1 a, T2 b) {
	return b < a ? a : b;
}

//before C++14
template<typename T1, template T2>
auto max(T1 a, T2 b) -> decltype(true ? a : b);

//但是存在一个问题，如果T是引用类型，返回类型就会被推断为引用
template<typename T1, template T2>
auto max(T1 a, T2 b) -> typename std::decay<decltype(true ? a : b)>::type {
	return b < a ? a : b;
}
//这里需要用类型萃取出目标类型
```

**将返回类型声明为公共类型**

```
template<typename T1, template T2>
std::common_type_t<T1, T2> max(T1 a, T2 b) { //C++14
	return b < a ? a : b;
}
```

什么叫做**公共类型**呢？对于某些类型的特化来决定目标类型。

比如::max(2, 2.1)和::max(2.1, 2)都是返回double类型。



### 2. 默认模板参数

```c++
template<typename T1, typename T2, typename RT = 
std::decay_t<decltype(true ? T1() : T2())>>
RT max(T1 a, T2 b) {
	return b < a ? a : b;
}
//also the same with common type
```



### 3. 函数模板的重载

```c++
int max(int a, int b) {
	return b < a ? a : b;
}

template<typename T>
T max(T a, T b) {
	reutn b < a ? a : b;
}
```

一个非模板函数可以和一个同名函数共存，并且这个同名函数可以实例化出与非模板函数同类型的调用参数。

**优先选择更匹配的；同条件，优先选择非模板参数**。

```c++
::max<>(7, 42); //显示使用模板调用
::max('a', 42,7) //模板推断不允许自动类型推导
```



## 类模板









## 二、类模板

+ 在一个类模板内出现的自身模板名，等价于该模板被调用所生成的实例。
+ 如果类模板参数有默认值，可以在模板实参列表中省略，但是**尖括号**无法省略。

简要介绍几个类模板的用法：

### 成员函数模板

> 类中的成员函数模板可以在类中当场实现，也可以在类外单独实现。当然，类模板的成员函数可以有额外的模板参数。

成员函数模板的参数不能与类模板参数同名。

在类外实现函数的时候需要使用**两个template**。



### 友元函数/类模板

任何友元实体都可以访问任意私有资源。



### 类模板的静态成员

类模板静态成员变量的实现与类模板实现放在同一可见范围内。

